{"ast":null,"code":"// http://jsfiddle.net/danmana/5mNNU/\nconst htmlSubstring = (s, n) => {\n  var m,\n      r = /<([^>\\s]*)[^>]*>/g,\n      stack = [],\n      lasti = 0,\n      result = ''; //for each tag, while we don't have enough characters\n\n  while ((m = r.exec(s)) && n) {\n    //get the text substring between the last tag and this one\n    var temp = s.substring(lasti, m.index).substr(0, n); //append to the result and count the number of characters added\n\n    result += temp;\n    n -= temp.length;\n    lasti = r.lastIndex;\n\n    if (n) {\n      result += m[0];\n\n      if (m[1].indexOf('/') === 0) {\n        //if this is a closing tag, than pop the stack (does not account for bad html)\n        stack.pop();\n      } else if (m[1].lastIndexOf('/') !== m[1].length - 1) {\n        //if this is not a self closing tag than push it in the stack\n        stack.push(m[1]);\n      }\n    }\n  } //add the remainder of the string, if needed (there are no more tags in here)\n\n\n  result += s.substr(lasti, n); //fix the unclosed tags\n\n  while (stack.length) {\n    result += '</' + stack.pop() + '>';\n  }\n\n  return result;\n};\n\nexport default htmlSubstring;","map":{"version":3,"sources":["/home/ankit/Desktop/Ankit/May/may-10/Stackoverflow-Clone-Frontend/src/services/htmlSubstring.js"],"names":["htmlSubstring","s","n","m","r","stack","lasti","result","exec","temp","substring","index","substr","length","lastIndex","indexOf","pop","lastIndexOf","push"],"mappings":"AAAA;AACA,MAAMA,aAAa,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC5B,MAAIC,CAAJ;AAAA,MAAOC,CAAC,GAAG,mBAAX;AAAA,MACIC,KAAK,GAAG,EADZ;AAAA,MAEIC,KAAK,GAAG,CAFZ;AAAA,MAGIC,MAAM,GAAG,EAHb,CAD4B,CAM5B;;AACA,SAAO,CAACJ,CAAC,GAAGC,CAAC,CAACI,IAAF,CAAOP,CAAP,CAAL,KAAmBC,CAA1B,EAA6B;AACzB;AACA,QAAIO,IAAI,GAAGR,CAAC,CAACS,SAAF,CAAYJ,KAAZ,EAAmBH,CAAC,CAACQ,KAArB,EAA4BC,MAA5B,CAAmC,CAAnC,EAAsCV,CAAtC,CAAX,CAFyB,CAGzB;;AACAK,IAAAA,MAAM,IAAIE,IAAV;AACAP,IAAAA,CAAC,IAAIO,IAAI,CAACI,MAAV;AACAP,IAAAA,KAAK,GAAGF,CAAC,CAACU,SAAV;;AAEA,QAAIZ,CAAJ,EAAO;AACHK,MAAAA,MAAM,IAAIJ,CAAC,CAAC,CAAD,CAAX;;AACA,UAAIA,CAAC,CAAC,CAAD,CAAD,CAAKY,OAAL,CAAa,GAAb,MAAsB,CAA1B,EAA6B;AACzB;AACAV,QAAAA,KAAK,CAACW,GAAN;AACH,OAHD,MAGO,IAAIb,CAAC,CAAC,CAAD,CAAD,CAAKc,WAAL,CAAiB,GAAjB,MAA0Bd,CAAC,CAAC,CAAD,CAAD,CAAKU,MAAL,GAAc,CAA5C,EAA+C;AAClD;AACAR,QAAAA,KAAK,CAACa,IAAN,CAAWf,CAAC,CAAC,CAAD,CAAZ;AACH;AACJ;AACJ,GAzB2B,CA2B5B;;;AACAI,EAAAA,MAAM,IAAIN,CAAC,CAACW,MAAF,CAASN,KAAT,EAAgBJ,CAAhB,CAAV,CA5B4B,CA8B5B;;AACA,SAAOG,KAAK,CAACQ,MAAb,EAAqB;AACjBN,IAAAA,MAAM,IAAI,OAAOF,KAAK,CAACW,GAAN,EAAP,GAAqB,GAA/B;AACH;;AAED,SAAOT,MAAP;AAEH,CArCD;;AAuCA,eAAeP,aAAf","sourcesContent":["// http://jsfiddle.net/danmana/5mNNU/\nconst htmlSubstring = (s, n) => {\n    var m, r = /<([^>\\s]*)[^>]*>/g,\n        stack = [],\n        lasti = 0,\n        result = '';\n\n    //for each tag, while we don't have enough characters\n    while ((m = r.exec(s)) && n) {\n        //get the text substring between the last tag and this one\n        var temp = s.substring(lasti, m.index).substr(0, n);\n        //append to the result and count the number of characters added\n        result += temp;\n        n -= temp.length;\n        lasti = r.lastIndex;\n\n        if (n) {\n            result += m[0];\n            if (m[1].indexOf('/') === 0) {\n                //if this is a closing tag, than pop the stack (does not account for bad html)\n                stack.pop();\n            } else if (m[1].lastIndexOf('/') !== m[1].length - 1) {\n                //if this is not a self closing tag than push it in the stack\n                stack.push(m[1]);\n            }\n        }\n    }\n\n    //add the remainder of the string, if needed (there are no more tags in here)\n    result += s.substr(lasti, n);\n\n    //fix the unclosed tags\n    while (stack.length) {\n        result += '</' + stack.pop() + '>';\n    }\n\n    return result;\n\n}\n\nexport default htmlSubstring;"]},"metadata":{},"sourceType":"module"}